---
caption: #what displays in the portfolio grid:
  title: 컴퓨터 네트워크 4단원
  subtitle: 네트워크 계층 - 데이터 영역
  thumbnail: https://velog.velcdn.com/images/dongchyeon/post/79bef008-235f-43ae-b7b0-1244bad2f892/image.png
  
#what displays when the item is clicked:
title: 컴퓨터 네트워크 4단원
subtitle: 네트워크 계층 - 데이터 영역
image: https://velog.velcdn.com/images/dongchyeon/post/79bef008-235f-43ae-b7b0-1244bad2f892/image.png #main image, can be a link or a file in assets/img/portfolio
---

두 호스트 H1과 H2가 있을 때, 네트워크 계층은 두 호스트 중 하나의 트랜스포트 계층 세그먼트를 추출하여 H2의 트랜스포트 계층까지 전달하는 역할을 한다.

송신측: 세그먼트를 데이터그램으로 캡슐화
수신측: 트랜스포트 계층으로 세그먼트를 전달

## 포워딩과 라우팅

`포워딩` : 패킷이 라우터의 입력 링크에 도달했을 때 적절한 라우터의 출력 링크로 이동시킨다.
`라우팅` : 송신자가 수신자에게 패킷을 전송할 때 출발지에서 목적지까지 패킷이 이동하는 경로를 결정한다.

## Data plane과 Control plane

`Data plane` : 로컬, 라우터별 기능으로, 라우터의 입력 포트로 도착한 데이터그램이 라우터의 출력포트로 전달되는 방법을 결정
`Control plane` : 네트워크 전체적인 논리로, 출발지 호스트에서 도착지 호스트까지의 경로 상에서 데이터그램이 라우터들 사이에서 어떻게 라우팅되는지 결정

### 포워딩 테이블

![](https://velog.velcdn.com/images/dongchyeon/post/79bef008-235f-43ae-b7b0-1244bad2f892/image.png)

라우터가 도착하는 패킷 헤더의 필드값을 포워딩 테이블의 내부 색인으로 사용하여 패킷을 전달

### Data plane: 전통적인 접근 방법

라우팅 알고리즘이 각각의 모든 라우터에서 실행되며, 라우터는 포워딩과 라우팅 기능을 모두 갖고 있어야 한다.
또한, 한 라우터의 라우팅 알고리즘 기능은 다른 라우팅 알고리즘과 소통하며 포워딩 테이블의 값을 계산한다.

### Data plane: SDN 접근 방법

![](https://velog.velcdn.com/images/dongchyeon/post/4e3b25da-cbef-4c1a-8733-2b077044ed9e/image.png)

라우터로부터 물리적으로 분리된 원격 컨트롤러 컴퓨터와 각각의 라우터에 의해 사용될 포워딩 테이블을 분배

## 네트워크 서비스 모델

### 각각의 Datagram에 대한 서비스
* 보장된 전달
* 전달간의 40 msec 미만의 지연 보장

### Datagram의 흐름에 대한 서비스
* Datagram 전달 시 순서 보장
* 전달 간 최소 대역폭 보장

## 라우터 내부 구조

![](https://velog.velcdn.com/images/dongchyeon/post/dc211563-b69c-45d6-be91-158449d5e6a5/image.png)

* `입력 포트`
	- 입력 포트의 맨 왼쪽와 오른쪽 박스는 라우터로 들어오는 입력 링크로, 물리 계층 기능을 수행한다.
	- 입력 포트는 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능을 수행한다. 이것은 입력 및 출력 포트에서 미들박스로 표시된다.
	- 입력 포트의 가장 오른쪽에서는 검색 기능을 수행하며 여기서 포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정한다.
* `스위치 구조`
	- 스위치 구조는 라우터의 입력 포트와 출력 포트를 연결한다.
	- 라우터 내부에 포함되어 있다.
* `출력 포트`
	- 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송한다.
* `라우팅 프로세서`
	- Data plane 기능을 수행한다.
	- 전통적인 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산한다.
	- SDN 라우터에서는 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력 포트에 이러한 엔트리를 설치한다.

## 입력 포트 처리 및 목적지 기반 전송

![](https://velog.velcdn.com/images/dongchyeon/post/c2b48558-d35d-4cab-a854-8f697a651956/image.png)

라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색한다.

포워딩 테이블은 라우팅 프로세서에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신된다.

### 분산화된 스위칭
- `목적지 기반 포워딩(Destination-based-forwarding)` : 목적지 IP 주소에만 기반하여 포워딩을 수행
- `일반화된 포워딩(Generalized forwarding)` : IP의 헤더 필드 값에 기반하여 포워딩 수행

### 목적지 주소 범위 포워딩 테이블

![](https://velog.velcdn.com/images/dongchyeon/post/366fb5c7-6389-46b1-a64f-b7e55029b68a/image.png)

목적지 주소 범위에 따라 보내는 링크를 결정해 포워딩 테이블을 구성할 수 있다.

### 프리 픽스 포워딩 테이블

![](https://velog.velcdn.com/images/dongchyeon/post/f9575ddc-715a-425f-ba29-89e38b5980ae/image.png)

패킷의 목적지 주소의 `프리픽스(prefix)`를 테이블의 엔트리와 매치한다.

`11001000 00010111 00010110 10100001` 라면 앞의 21개의 비트가 테이블의 첫번째 엔트리와 매치되므로 라우터는 이 패킷을 링크 인터페이스 0으로 보낸다.

`11001000 00010111 00011000 10101010`라면 처음 24비트는 2번째에 처음 21비트는 3번째 매치되는 경우 라우터는 `최장 프리픽스 매치 규칙(longest prefisx matching rule)`을 사용하므로 패킷을 링크 인터페이스 1로 보낸다.

## 스위칭

스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 스위칭 되는 구조를 통과하므로 라우터의 핵심이다.

### 메모리를 통한 교환

![](https://velog.velcdn.com/images/dongchyeon/post/7917a519-3f49-4b9a-8f33-33f28d896427/image.png)

초기의 라우터는 라우터 프로세서를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터다. 패킷이 시스템의 메모리로 복사되며 소프트웨어로 처리하기 때문에 속도가 느리다.

### 버스를 통한 교환

![](https://velog.velcdn.com/images/dongchyeon/post/903348be-1e0d-4d6c-a37e-3e562b70e49b/image.png)

입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다.
동시에 여러 패킷이 다른 입력 포트에 있는 라우터에 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷이 대기해야 한다.
모든 패킷이 하나의 버스를 통과해야하므로 라우터의 교환 속도는 버스의 대역폭에 의해 제한된다.

### 상호 연결 네트워크를 통한 교환

![](https://velog.velcdn.com/images/dongchyeon/post/1839ee87-cf25-446c-913f-8219e01a4e57/image.png)

바니안 네트워크, 크로스바 및 다른 상호 연결 네트워크는 초기에 다중 프로세서에서 프로세서를 연결하기 위해 개발되었다.

크로스바 스위치는 N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크이다.

각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다.

이를 통해 앞의 두가지 방식과 달리 크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있다.

그러나 두 개의 서로 다른 입력 포트에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야 한다.

좀 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 통해 동시에 전달할 수 있도록 여러 단계의 스위칭 요소를 사용한다.

## 출력 포트 처리

![](https://velog.velcdn.com/images/dongchyeon/post/3264512f-6158-4046-8aa1-b02595ae1163/image.png)

### 입력 큐잉

지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않는다면?
-> 패킷이 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야 한다.

이 큐잉의 결과를 보기 위해 크로스바 스위치 구조를 가정해보자.

1. 모든 링크의 속도는 같다.
2. 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다.
3. FCFS (First-Come-First-Served) 방식으로 패킷은 입력 큐에서 출력 큐로 이동한다.

출력 포트가 다르다면 여러 패킷이 병렬로 전달 가능하지만, 같다면 하나의 패킷만 지정된 출력 포트로 전송이 가능하고 나머지 패킷은 기다려야 한다.

![](https://velog.velcdn.com/images/dongchyeon/post/f8289e7f-2580-4c5b-819b-9591b0c7dbde/image.png)

왼쪽 최상단 큐의 앞쪽부터 먼저 패킷을 전송한다고 가정해보자.

왼쪽 최하단 큐의 가장 앞쪽 패킷은 최상단 큐의 패킷과 출력 포트가 같으므로 대기하여야 하고, 최하단 큐의 두번째 패킷은 출력 포트가 다름에도 앞의 패킷 때문에 대기해야 한다.

이처럼 큐의 앞쪽에 있는 패킷이 다른 패킷의 이동을 방해하는 것을 `HOL(Head-of-the-line) Blocking` 이라고 한다.

### 출력 큐잉

![](https://velog.velcdn.com/images/dongchyeon/post/d545b2c6-fe53-481f-90ca-f9a277abe64f/image.png)

큐의 공간이 충분하지 않을 때, 즉 메모리가 충분하지 않을 때 도착한 패킷을 삭제하거나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간을 확보해야 한다.

## 패킷 스케줄링

`스케줄링` : 링크에 보낼 다음 패킷을 선택하는 것

### FIFO 스케줄링

![](https://velog.velcdn.com/images/dongchyeon/post/dac7c461-0cf7-48fd-961c-39d4b8cb6c48/image.png)

FIFO 스케줄링은 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다.

도착한 패킷을 담을 버퍼 공간이 충분하지 않은 경우 도착 패킷의 공간을 확보하기 위한 큐의 패킷 폐기 정책은 다음과 같다.

* Tail drop: 도착하는 패킷을 버림
* 우선순위: 우선순위에 따라 패킷을 버림
* 랜덤: 랜덤으로 패킷을 버림

### 우선순위 스케줄링

![](https://velog.velcdn.com/images/dongchyeon/post/bd6e679e-e5ef-4ac6-8ece-418dab0982cb/image.png)

![](https://velog.velcdn.com/images/dongchyeon/post/5069ac09-08c7-478b-aa74-1eb3bcf702d2/image.png)

출력 링크에 도착한 패킷을 우선순위 클래스로 분류한다.
전송할 패킷을 선택할 때 가장 높은 우선순위 클래스에서 패킷을 전송한다.
우선순위가 동일한 패킷들 중에서의 선택은 FIFO 방식으로 행해진다.

### 라운드 로빈(RR) 스케줄링

![](https://velog.velcdn.com/images/dongchyeon/post/609aac00-e8cf-4dec-aa81-08d7979e0af8/image.png)

우선순위 스케줄링과 같이 클래스들로 분류하지만 클래스 간의 우선순위가 존재하지 않으며, 클래스 간에 서비스를 번갈아서 제공한다.
각 클래스의 큐를 순환적으로 스캔해, 완료된 패킷을 보낸다.

### WFQ(Weighted Fair Queueing) 스케줄링

![](https://velog.velcdn.com/images/dongchyeon/post/29873a06-98cb-4cfc-b91d-4e736f377300/image.png)

라운드 로빈 스케줄링의 가장 일반적인 구현 형태이다. 각 클래스는 가중치에 따라 서비스 제공 시간을 보장받는다.

## IPv4 데이터그램

### IPv4 데이터그램 포맷

![](https://velog.velcdn.com/images/dongchyeon/post/6e2c3ced-3759-45b0-98ad-ec9c549b09f9/image.png)

* `버전 번호` : 4비트로 데이터그램의 IP 프로토콜 버전(IPv4, IPv6)을 명시한다.
* `헤더 길이` : IP 데이터그램에서 실제 payload가 시작되는 것을 결정하며 대부분의 IPv4는 옵션을 포함하지 않으므로 IPv4 데이터그램 헤더는 20바이트이다.
* `데이터그램 길이` : 바이트로 계산한 IP 데이터그램의 전체 길이다.
* `TTL(Time to live)` : 네트워크에서 데이터그램이 무한히 순환하지 않도록 한다. 라우터가 데이터그램을 처리할 때마다 감소하고, 0이 되면 데이터그램을 폐기한다.
* `헤더 체크섬` : 수신한 IP 데이터그램의 비트 오류를 탐지하며 라우터는 오류 검출된 데이터그램을 폐기한다.

### IPv4 단편화, 재결합

네트워크는 링크는 MTU(Max Transfer Size)를 가진다. 링크 계층 프로토콜마다 다른 링크 타입과 MTU를 가지므로 네트워크는 큰 IP datagram을 분할할 필요성이 있다. 쪼개진 datagram을 최종 목적지에서 재결합(reassemly)된다. IP 헤더를 통해 본래 하나의 datagram이었는지 구분하고 순서를 확인한다.

![](https://velog.velcdn.com/images/dongchyeon/post/044324b5-20d2-4e51-94c1-678b49e1482b/image.jpg)

### IPv4 주소체계

호스트는 일반적으로 네트워크와 연결되는 하나의 링크를 가지며 호스트 IP가 데이터그램을 보낼 때 이 링크를 통해 데이터링크를 보낸다.
이 때, 호스트와 물리적 링크 사이의 경계를 `인터페이스(interface)`라고 한다. 라우터는 여러 개의 링크와 연결되고, 링크와 라우터 사이도 `인터페이스(interface)`로 이루어져있어 여러개의 `인터페이스(interface)`를 가진다.

### 서브넷과 IP 주소

각 IP 주소는 32비트 길이로 2^32개의 주소를 사용할 수 있다. 일반적으로 주소의 각 바이트를 십진수로 표현하고 주소의 다른 바이트와 점으로 구분하는 십진 표기법을 사용한다.
IP 주소의 일부는 연결된 `서브넷`이 결정한다.

![](https://velog.velcdn.com/images/dongchyeon/post/d0d2be0e-408b-4810-a750-92896b21b12f/image.png)

왼쪽 3개의 호스트와 라우터 인터페이스는 모두 223.1.1.xxx 형식의 IP 주소를 가진다. 또, 4개의 인터페이스가 중개하는 라우터 없이 하나의 네트워크에 서로 연결되어 있다.

세 호스트의 인터페이스들과 하나의 라우터 인터페이스로 연결된 네트워크는 `서브넷(subnet)`을 구성한다고 한다.

IP 주소체계는 이 서브넷에 `223.1.1.0/24`라는 주소를 할당하는데 여기서 `/24`는 서브넷 마스크라 부르는데, 왼쪽 24비트가 서브넷 주소라는 것을 가리킨다.

호스트 id의 일부를 네트워크 id로 활용하여 네트워크 관리가 쉽다는 장점이 있다.

서브넷의 정의
> 서브넷을 결정하기 위해 먼저 호스트나 라우터에서 각 인터페이스를 분리하고 고립된 네트워크를 만든다. 이 고립된 네트워크의 종단점은 인터페이스의 끝이 된다. 이렇게 고립된 네트워크 각각을 서브넷이라고 부른다.

### CIDR (Classless InterDomain Routing)

인터넷 주소 할당 방식 중 하나로 주소 형식은 a.b.c.d/x이며, 여기서 x는 서브넷 부분의 비트 수를 의미한다.

![](https://velog.velcdn.com/images/dongchyeon/post/96ecba77-d87a-4ca1-99f8-f868a0a29bd4/image.jpg)

### 클래스 주소 체계

CIDR가 채택되기 전에는 IP 주소의 네트워크 부분은 8, 16, 24 비트로 제한했고 각각의 비트를 서브넷 주소로 갖는 서브넷을 각각 A, B, C 클래스 네트워크로 분류했기 때문에 이러한 주소체계는 `클래스 주소체계`라고 알려졌다.

![](https://velog.velcdn.com/images/dongchyeon/post/31502a8e-0b5b-40ac-b650-0d1dfecd867a/image.png)

* 클래스 A: 네트워크 개수 - 2^7 = 128 호스트 개수 - 256x256x256 = 16,777,216
* 클래스 B: 네트워크 개수 - 2^8 x 2^8 = 16,000 호스트 개수 - 256x256 = 65,536
* 클래스 C: 네트워크 개수 - 2^5 x 2^8 x 2^8=2,097,152 호스트 개수 - 256

클래스 C의 경우 Supernet을 같이 사용해 네트워크 주소를 유동적으로 조정해 더 많은 호스트를 수용가능하다.

### DHCP (Dynamic Host Configuration Protocol)

호스트가 네트워크에 참여할 때 네트워크 서버로부터 동적으로 IP 주소를 얻을 수 있도록 한다.
주소를 사용하는 동안에만 주소를 보유하게 할 수 있고, 주소의 재사용을 가능하게 한다. 따라서 IP 주소의 효율적인 사용이 가능하다.
이동 사용자가 네트워크에 참여할 수 있도록 지원한다.

![](https://velog.velcdn.com/images/dongchyeon/post/e201b6bc-d002-48d7-9d41-ea19da10adfa/image.png)

위 그림은 새로운 호스트가 도착할 경우 DHCP 프로토콜의 4단계 과정을 보여준다.

1. `DHCP 서버 발견` : 새롭게 도착한 호스트는 상호작용할 DHCP를 발견하고 DHCP 발견 메시지를 보낸다.
2. `DHCP 서버 제공` : DHCP 발견 메시지를 받은 DHCP 서버는 DHCP 제공 메시지를 클라이언트로 응답한다.
3. `DHCP 요청` : 새롭게 도착한 클라이언트는 하나 이상의 서버 제공자 중에서 선택할 것이고 선택된 제공자에게 파라미터 설정으로 되돌아오는 DHCP 요청 메시지로 응답한다.
4. `DHCP ACK` : 서버는 DHCP 요청 메시지에 대해 요청된 파라미터를 확인하는 DHCP ACK 메시지로 응답한다.

클라이언트가 DHCP ACK를 받으면 상호작용이 종료되고 클라이언트는 임대 기간동안 할당 IP 주소를 사용할 수 있다.

### 네트워크 주소 변환 (NAT)

모든 호스트가 서브넷으로부터 IP를 할당받고 할 때 네트워크가 현저하게 커지면 큰 주소 블록이 할당되어야 한다. 이를 위해 `NAT`를 사용할 수 있다.

현실에서 NAT를 사용하는 경우를 살펴보자.

가정내 여러 개의 컴퓨터, 스마트폰이 있을 때 각각에 IP 주소를 할당하는 것이 아니라 인터넷 공유기 1대에만 IP 주소를 1개 할당한다.
같은 공유기에 연결된 기기에는 가상(사설) IP를 부여하고, 외부에서는 하나의 IP를 공유한다.
이때 사설 IP는 내부에서만 사용하고, 공식 IP는 외부에서 대표 IP로 사용한다.

## IPv6

### IPv6 데이터그램 포맷

![](https://velog.velcdn.com/images/dongchyeon/post/be609e31-d190-4d21-99a4-e8ec05610de1/image.png)

* 확장된 주소 기능
  - IP 주소 크기를 32비트에서 128비트로 확장했다.
* 간소화된 40바이트 헤더
  - 40 바이트의 헤더는 라우터가 IP 데이터그램을 더 빨리 처리하게 해주고 새로운 옵션 인코딩을 통해 유연한 옵션 처리를 가능하게 해준다.
* 흐름 레이블링
  - 같은 흐름 안의 데이터그램을 식별하게 해준다.
  
`흐름` : 동일한 특성을 갖는 패킷들, 동일한 서비스를 받는 패킷들 (동일한 목적지 또는 동일한 경로 또는 동일한 응용에 가는 패킷)

### IPv4로부터 달라진 점

* 체크섬 제거
  - IPv4에서는 라우터에서 TTL 필드(IPv6의 hop limits 필드와 유사)를 포함하는 IPv4 헤더의 체크섬을 재계산해야 했다. IPv6에서 체크섬을 제거함으로써 라우터에서 처리해야 할 작업을 간소화하여 처리 속도를 향상시킬 수 있었다.
* 옵션
  - 표준 IP 헤더에 옵션 필드가 포함되어 있지 않지만, 'Next Header' 필드를 통해 다음 헤더로 포인팅하는 기능이 있다.
* ICMPv6
  - IPv4의 ICMP와 유사한 목적과 기능을 가지고 있지만 IPv6 환경에 특화된 내용을 포함하고 있다.

### IPv4에서 IPv6로의 전환

IPv6는 IPv4 데이터그램을 보내고 라우팅하여 받을 수 있는 새 IPv6 시스템이 있는 반면에, IPv4로 구축된 시스템은 IPv6 데이터그램을 처리할 수 없다.

`터널링` : IPv4 라우터 간에 IPv6 데이터그램을 운반하기 위해 IPv4의 payload에 넣는 것

![](https://velog.velcdn.com/images/dongchyeon/post/03fde439-a3db-4eac-84ad-bff9a9095dee/image.jpg)
