---
caption: #what displays in the portfolio grid:
  title: 컴퓨터 네트워크 3단원
  subtitle: 전송 계층
  thumbnail: https://velog.velcdn.com/images/dongchyeon/post/1d3fab91-b389-413e-ad5c-e0fb6787a65b/image.jpg
  
#what displays when the item is clicked:
title: 컴퓨터 네트워크 3단원
subtitle: 전송 계층
image: https://velog.velcdn.com/images/dongchyeon/post/1d3fab91-b389-413e-ad5c-e0fb6787a65b/image.jpg #main image, can be a link or a file in assets/img/portfolio
---

# TCP 프로토콜

## 연결 지향 프로토콜

- 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정하여 통신하는 방식으로 가상의 연결통로를 가상회선이라 한다.
- 논리적인 연결통로를 통해 데이터를 주고받음으로써 데이터의 전송순서를 보장해준다. 순서제어라고도 한다.
- 데이터를 바이트 단위로 나눠서 전송하는 스트림 기반의 통신을 사용한다.

두 개의 프로세스가 가상의 채널로 연결
송신 프로세스는 바이트 스트림 생성(쓰기) / 수신 프로세스는 바이트 스트림 소비(읽기)

## TCP의 연결 시작 (3-way handshaking)

<img src = "https://velog.velcdn.com/images/dongchyeon/post/1d3fab91-b389-413e-ad5c-e0fb6787a65b/image.jpg" width="100%">

1. 클라이언트가 서버에게 SYN 패킷을 전송해 연결을 요청한다.
2. 서버는 SYN 패킷을 받았다는 것을 확인하고, SYN + ACK 패킷을 클라이언트에 전송해 연결을 수락한다.
3. 클라이언트는 서버가 SYN + ACK 패킷을 보낸 것을 확인하고, ACK 패킷을 서버에게 전송해 연결되었음을 알린다.

## TCP의 연결 종료 (4-way handshaking)

1. 클라이언트가 연결 종료를 알리는 FIN 패킷을 서버에 보낸다.
2. 서버는 FIN 패킷을 받고, 확인 메시지인 ACK 패킷을 클라이언트에 전송한다.
3. 서버는 더 이상 보낼 데이터가 없다면 FIN 패킷을 클라이언트에 보낸다.
4. 클라이언트는 FIN 패킷을 받고 ACK 패킷을 서버에 보내고 연결을 종료한다.

## ACK, NAK

ACK(Acknowledgement)는 데이터 수신 측에서 패킷을 올바르게 받았다는 뜻으로, 다음으로 필요한 패킷의 번호와 함께 보내진다.

NAK(Negative Acknowledgement)는 받은 패킷에 오류가 있거나 잘못된 순서로 받았다는 뜻으로, 문제가 있는 패킷의 번호와 함께 보내진다.

## 흐름제어

- 상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송하는 것
- 흐름제어를 위해 슬라이딩 윈도우 방식을 사용한다. 이는 상대방이 수신 가능한 크기 내에서 데이터를 연속해서 전송하는 방식으로 매 세그먼트 전송 시마다 수신확인응답(ACK)을 수신한 후 전송하게 되면 왕복시간(RTT)이 길 경우 단위 시간당 데이터 전송량이 매우 떨어지므로 효율적으로 전송하기 위해 상대방이 받을 수 있는 범위 내에서 연속적으로 전송한다.

### 1. Stop and Wait

송신측에서 패킷을 보내면 일단 멈추고 (Stop),
수신측에서 ACK가 올 때까지 기다린다. (Wait)
패킷을 하나씩 보내고 기다리므로 매번 패킷의 RTT(Round Trip Time)만큼의 시간이 걸리므로 비효율적이다.

### 2. Sliding Window

일정 개수까지는 일일히 수신측에서 확답을 안 받아도 연속해서 보낼 수 있다.
여기서 '일정 개수'를 정하는 것을 윈도우(window)라고 한다.
수신측이 정한 윈도우의 크기 n개만큼 송신측은 패킷을 연속해서 보낼 수 있다.
연속해서 보낸 패킷에 대해 수신측이 ACK를 보내면 송신측은 해당 윈도우를 그만큼 확장하낟.

예를 들어 n=5이고 송신측에서 1, 2, 3, 4, 5의 패킷을 보낼 준비 후 1, 2를 보내면 윈도우는 3, 4, 5가 된다.
이후 수신측에서 1, 2에 대해 ACK가 오면 윈도우는 우측으로 확장되어 3, 4, 5, X, X (X는 빈 공간) 이 된다. 이 때 빈 공간에는 송신측에서 새로 생산된 패킷이 들어갈 수 있다.

## 오류 제어
- 데이터의 오류나 누락없이 안전한 전송을 보장
- 오류 또는 누락 발생 시 재전송을 수행하여 이를 보장

### 1. Stop and Wait

송신측에서 패킷을 보내면 일단 멈추고 (Stop),
수신측에서 ACK가 올 때까지 기다린다. (Wait)
패킷을 하나씩 보내고 기다리므로 매번 패킷의 RTT(Round Trip Time)만큼의 시간이 걸리므로 비효율적이다.

### 2. Go-Back-N

오류 패킷 이후를 모두 재전송한다. 예를 들어 1, 2, 3, 4, 5 를 보내고 ACK(4)까지 받은 상황이 있다고 하자. ACK(4)를 받았기 때문에 3번까진 제대로 왔음이 확인되었다. 이때 타임아웃이 발생하거나 NAK를 받았다면 3번 패킷 이후의 4번 패킷부터 싹 다 재전송한다.

### 3. Selective Repeat

문제가 발생한 패킷만 재전송한다. Go-Back-N 방식과는 다르게 순서가 꼬일 수 있으므로 수신측은 버퍼에 이를 저장하고 패킷의 순서를 맞추기 위해 정렬해야 한다.

## 혼잡 제어
- 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어
- 혼잡정도에 대한 판단기준을 데이터의 손실 발생 유무로 판단한다. 전송한 데이터에 누락이 발생하면 네트워크가 혼잡한 상태로 판단하여 전송량을 조절한다.

### 1. AIMD (Additive Increase Multicative Decrease)

패킷 하나를 보내고, ACK가 오면 윈도우의 크기를 1씩 증가시킨다.
NAK나 타임아웃이 발생하면 절반으로 감소시킨다.

초기에 큰 대역폭을 사용하지 못한다는 단점이 있다.

![](https://velog.velcdn.com/images/dongchyeon/post/bae29301-5e9a-4dd3-80b9-a4680517c964/image.png)


### 2. Slow Start

AIMD의 초기에 큰 대역폭을 사용하지 못한다는 단점을 커버할 수 있다.
Slow Start는 윈도우의 크기를 2배씩 늘리고, 혼잡 현상이 발생하면 크기를 1로 줄인다.
처음엔 네트워크의 수용량을 예측할 수 있는 정보가 없지만 시간이 지나면서 혼잡 현상이 발생했던 윈도우의 크기가 얼만지를 알아낼 수 있다. 이때 이 크기의 절반까지는 2배씩 증가시키고 그 이후부턴 1씩 증가시킨다.

![](https://velog.velcdn.com/images/dongchyeon/post/f0850a98-b503-42a3-8dbc-6d4e28522e27/image.png)

### Fast Retransmit

만약 세 번의 중복 ACK가 도달하면 TimeOut이 안되었더라도 재전송한다.