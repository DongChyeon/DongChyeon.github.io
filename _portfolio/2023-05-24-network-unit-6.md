---
caption: #what displays in the portfolio grid:
  title: 컴퓨터 네트워크 6단원
  subtitle: 링크 계층과 LAN
  thumbnail: https://velog.velcdn.com/images/dongchyeon/post/3209aea1-e0e2-4ec9-8085-0dc18cadf207/image.png
  
#what displays when the item is clicked:
title: 컴퓨터 네트워크 6단원
subtitle: 링크 계층과 LAN
image: https://velog.velcdn.com/images/dongchyeon/post/3209aea1-e0e2-4ec9-8085-0dc18cadf207/image.png #main image, can be a link or a file in assets/img/portfolio
---

## 링크 계층 소개

### 노드
링크 계층 프로토콜을 실행하는 장치

### 링크
통신 경로상의 인접한 노드들을 연결하는 통신 채널
데이터그램을 출발지 호스트에서 목적지 호스트로 이동시키기 위해서는 데이터그램을 종단 간 경로의 개별 링크들로 이동시켜야 한다.

### 링크 계층이 제공하는 서비스

* `프레임화(framing)`
  - 데이터그램을 링크상으로 전송하기 전에 링크 계층 프레임에 캡슐화한다.
* `링크 접속(link access)`
  - `매체 접속 제어(medium access control, MAC)` 프로토콜은 링크상으로 프레임을 전송하는 규칙을 명시한다.
  - MAC 주소는 출발지와 목적지를 판별하기 위해 프레임의 헤더에 쓰인다.
* `신뢰적 전달`
  - `TCP`와 마찬가지로 확인 응답과 재전송을 위해 서비스를 제공한다.
  - `TCP`에서는 종단 간에 데이터를 재전송하는 것과 달리 링크 계층 프로토콜은 오류가 발생한 링크에서 오류를 정정한다.
* `오류 검출`
  - 신호의 약화나 전자기 잡음 때문에 전송된 프레임 비트를 반대로 오인할 수 있다.
  - 수신자가 에러를 발견하면 송신자에게 재전송을 요청하거나 프레임을 버리도록 한다.
* `오류 수정`
  - 수신자는 재전송을 사용하지 않고 비트 오류를 식별하고 수정한다.
  - 송신 노드에서 오류 검출 비트를 설정하게 하고 수신 노드에서 오류 검사를 수행하게 함으로써 가능하다.
  
  
### 링크 계층이 구현되는 위치

호스트에서 대부분의 경우 링크 계층은 `네트워크 인터페이스 컨트롤러(Network Interface Controller, NIC)`로 알려진 `네트워크 어댑터(Network Adapter)`에 구현된다.
  
링크 계층은 하드웨어와 소프트웨어의 조합이다.

### Adapter의 통신

* `송신자`
  - 프레임 안에 데이터그램을 캡슐화한다.
  - 에러 체크 비트, 흐름 제어 등을 추가한다.
* `수신자`
  - 에러를 검출하고 흐름제어를 한다.
  - 데이터그램을 추출하고, 수신자의 상위 레이어에 넘긴다.

## 오류 검출 및 정정 기술

![](https://velog.velcdn.com/images/dongchyeon/post/3209aea1-e0e2-4ec9-8085-0dc18cadf207/image.png)

비트 오류를 방지하기 위해 송신 노드에서 `데이터 D`에 `오류 검출 및 정정 비트(EDC)`를 첨가한다.

송신되는 `데이터 D`와 `EDC`는 전송 도중 변경될 수 있다.
즉, 수신자는 변경의 가능성이 있는 비트로 오류 검출 여부를 확인해야 한다.

또한, 오류 검출 및 정정 기술을 사용하더라도 여전히 미검출된 비트 오류가 있을 수 있다.

### 패리티 검사


#### 단일 패리티 비트

![](https://velog.velcdn.com/images/dongchyeon/post/e880e7df-ded1-45f0-b7f5-b2dfef986880/image.png)

데이터 D가 d개의 비트를 갖고 있다고 가정하자.
짝수 패리티 기법을 사용할 경우 단순히 D에  한 개의 `Parity bit`를 추가하고, d+1개의 비트에서는 1의 총 개수가 짝수가 되도록 `Parity bit`를 선택한다.
수신자는 수신된 d+1개의 bit에서 1개의 개수가 짝수임을 확인한다.

#### 2차원 패리티

![](https://velog.velcdn.com/images/dongchyeon/post/cd689229-33c3-4b5f-8046-8e4247b9e208/image.png)

데이터 D에 있는 d 비트들은 i개의 행과 j개의 열로 나뉜다.
나뉜 각각의 행과 열에 대해 하나의 패리티 값이 계산된다.

### 체크섬(Checksum) 방법

d 비트들을 k 비트 정수처럼 다루어 이 k비트 정수들을 더해서 오류 검출 비트들로 사용한다.

#### 체크섬 동작 과정

`인터넷 체크섬(Internet checksum)`: 전송된 패킷의 오류를 검출한다.

* 송신자
  - 세그먼트의 내용을 16비트 정수처럼 다룬다.
  - 해당 세그먼트 내용의 16비트를 더해서 체크섬으로 사용한다.
  - UDP의 체크섬 필드에 이를 넣는다.
  
* 수신자
  - 수신한 패킷의 체크섬을 계산한다.
  - 계산한 체크섬이 받은 패킷의 체크섬 필드와 같은지 확인한다.
  
  1. 더한 값의 1의 보수가 인터넷 체크섬이 되며, 이를 세그먼트 헤더에 넣어준다.
  2. 수신자는 수신 데이터 합의 1의 보수를 취한 후 그 결과가 모두 1인 비트로 구성되어 있는지 계산함으로써 체크섬을 검사한다.
  3. 그 결과가 모두 1인 비트로 구성되어 있는지 계산함으로써 체크섬을 검사한다.
 
### 순환 중복 검사(CRC)

#### CRC 동작 과정

![](https://velog.velcdn.com/images/dongchyeon/post/2327a96b-4136-4d88-b3ef-41e1e0f7a30b/image.png)

1. 먼저 송신자와 수신자는 G로 표기되는 생성자로 알려진 r+1 비트 패턴에 대해 합의한다. 이때 G의 최상위 비트는 1이다.
2. 송신자는 D에 r개의 추가 비트 R을 선택해서 D 뒤에 덧붙인다.
   - 일반 이진 연산에서 2^k을 곱하는 것은 비트 패턴을 k개의 위치만큼 왼쪽으로 이동시키는 것과 같다. 즉, 위 그림의 식을 통해 d+r 패턴을 만들 수 있다.
   - 만들어진 d+r 비트 패턴은 모듈로 2 연산을 이용하면 G로 정확히 나누어진다.
3. 수신자는 d+r개의 수신 비트를 G로 나눈다. 만일 나머지가 0이 아니면 오류가 발생한 것이다.
  
 
#### R을 계산하는 과정

먼저 다음과 같은 식을 만족하는 n이 있도록 하는 R을 구해야 한다.

> D x 2^r XOR R = nG

즉, `D x 2^r XOR R`을 나머지 없이 G로 나눌 수 있도록 R을 선택해야 한다. 이 식의 양쪽에 R을 XOR하면 다음과 같다.

> D x 2^r = nG XOR R

이 식은 `D x 2^r`을 G로 나누면 나머지가 정확히 R이 되는 것을 뜻한다.
다시 말해, 다음처럼 R을 계산할 수 있다.

> R = 나머지 x [D x 2^r / G]


![](https://velog.velcdn.com/images/dongchyeon/post/34b8e138-b78f-4bef-9f0d-15a35f9723ab/image.png)

## 다중 접속 링크와 프로토콜

### 두 종류의 네트워크 링크

* `점대점 링크 (point-to-point link)`
  - 링크의 한쪽 끝에 한 송신자와 링크의 다른 쪽 끝에 한 수신자가 있다.
  - `PPP(point-to-point protocol)`과 `HDLC(high-level data link control)`이 여기에 속한다.
* `브로드캐스트 링크(broadcast link)`
  - 동일한 하나의 공유된 브로드캐스트 채널에 다수의 송신 노드 및 수신 노드가 연결된다.
  - 임의의 한 노드가 프레임을 전송하면 채널이 그 프레임을 브로드캐스트해서 다른 모든 노드가 그 프레임의 복사본을 수신하기 때문에 브로드캐스트 용어가 쓰인다.
  
### 다양한 다중 접속 채널

#### 다중 접속 문제

모든 노드가 프레임을 전송할 수 있으므로 2개 이상의 노드가 브로드캐스트 채널에서 직접 통신할 수 있고, 이런 일이 발생하면 모든 노드는 동시에 여러 개의 프레임을 받게 된다.

즉, 전송된 프레임들이 각 수신자에서 충돌하게 되고 어떤 수신 노드도 전송된 프레임의 의미를 파악할 수 없게 된다.

### 다중 접속 프로토콜 (MAC: Multiple Access Protocol)

초당 R 비트의 전송률을 갖는 브로드캐스트 채널에 대한 다중 접속 프로토콜은 다음과 같은 특성을 지니는 것이 바람직하다.

1. 단 하나의 노드가 전송할 데이터가 있을 대는 그 노드가 R bps의 처리율을 갖는다.
-> 하나의 노드가 전송을 도점할 수도 있음
2. M개의 노드가 전송할 데이터가 있을 때는 각 노드가 R/M bps의 처리율을 갖는다.
   - 항상이 아니며 각 노드가 정의된 시간 동안 R/M의 평균 처리율을 가짐을 의미한다. 
   -> 다수의 노드가 균등하게 전송
3. 분산되어 있어 고장으로 인해 전체 시스템을 정리할 수 있는 마스터 노드가 없다.
-> 조정 없이 개별적/분산적으로 처리
4. 단순해서 구현하는 데 비용이 적게 든다.

### 채널 분할 프로토콜

#### 시분할 다중화 (time-division multiplexing, TDM)
채널이 N개 노드를 지원하고 채널 전송률이 R bps라고 하자.
TDM은 시간을 `시간 프레임(time frame)`으로 나누고 또한 각 시간 프레임을 N개의 `시간 슬롯(time slot)`으로 나눈다.
그 후 N개의 노드에 각각 할당한다.
노드는 전송할 패킷이 있을 때마다 TDM 프레임에서 자신에게 할당된 시간 슬롯 동안 패킷을 전송한다.

#### 주파수 분할 다중화 (frequency-division multiplexing, FDM)
R bps의 채널을 R/N의 대역폭을 갖는 다른 주파수로 나눠서 각 주파수를 N개의 노드 중 하나에게 할당한다.
즉, 하나의 큰 R bps 채널로부터 N개의 R/N bps의 작은 채널을 만든다.

사용되지 않은 주파수는 낭비된다는 단점이 있다.

#### 코드 분할 다중 접속 (code division multiple access, CDMA)
CDMA는 다른 코드를 각 노드에게 할당한다.
노드는 전송하는 데이터 비트들을 자신의 유일한 코드로 인코딩한다.
-> 예시: 각 휴대폰의 신호를 각각 암호화하여 보내고 수신측에서는 암호화된 것을 해독

### 순번 프로토콜

#### Polling

`마스터 노드`와 `슬레이브 노드`가 존재한다. 마스터는 전송을 시작해도 되는 슬레이브를 순서대로 지정하고, 슬레이브는 지정받은 번호에 맞게 전송이 시작된다.

단점
* polling overhead 발생
* 지연 발생
* 마스터가 다운되면 시스템 전체 다운(=single point of failure)

#### Token Passing

하나의 네트워크에 참여한 모든 노드들이 `Token`을 공유한다. 그리고 해당 Token을 가진 자만이 데이터를 전송할 수 있다. 그리고 자신의 전송이 끝나면 다음 노드에 Token을 전달해 순서대로 데이터를 전송한다.

단점
* token overhead 발생
* token이 순서대로 돌면서 발생하는 지연
* Token 시스템이 죽으면 시스템 전체 다운(=single point of failure)

### 랜덤 접속 프로토콜

랜덤 접속 프로토콜에서 전송 노드는 항상 채널의 최대 전송률인 R bps로 전송한다.
충돌이 생기면 충돌과 관련한 각 노드는 프레임이 충돌 없이 전송될 때까지 자신의 프레임을 계속해서 재전송한다.

프레임이 충돌했을 때 즉시 재전송하지 않고, 랜덤 지연 시간 동안 기다린 후 재전송 한다.
즉, 출동했던 노드 중 하나는 다른 노드가 선택한 지연 시간보다 충분히 작은 지연시간을 선택함으로써 충돌 없이 프레임을 채널로 전송할 수 있다.

#### 알로하 (ALOHA)

순수 알로하 프로토콜에는 슬롯 개념이 없다.

* 모든 프레임은 같은 길이를 가지고 있으며 전송 시간도 동일하다.
* 각 노드는 프레임이 생성되면, 랜덤하게 각자 알아서 전송을 시작한다.
* 충돌이 발생하면 재전송한다. (이 때, 충돌 감지는 일정시간까지 에코가 오지 않을 때로 판단한다.)

![](https://velog.velcdn.com/images/dongchyeon/post/bb8ae802-b4e2-47ed-bae0-bf3d8a8d4b77/image.png)

프레임 i가 보내진 t0 전후에 보내진 다른 프레임이 있다면 충돌이 발생한다.

#### 슬롯 알로하 (slotted ALOHA)

![](https://velog.velcdn.com/images/dongchyeon/post/e45b5363-3799-4d30-aea1-1ce31c0408b0/image.png)

1. 전송할 새 프레임이 있으면 다음 슬롯이 시작할 때까지 기다렸다가 그 슬롯에 전체 프레임을 전송한다.
2. 만약, 충돌하지 않으면 노드는 성공적으로 자신의 프레임을 전송한 것이다. 따라서 그 프레임을 재전송할 필요가 없다.
3. 만약 충돌하면, 노드는 그 슬롯이 끝나기 전에 충돌을 검출한다. 노드는 그 프레임이 충돌 없이 전송될 때까지 확률 p(0~1 사이)로 해당 프레임을 다음 슬롯들에서 재전송한다.
4. 충돌하지 않을 때까지 3번 과정을 반복한다.

장점
* 하나의 활성노드로 하여금 채널의 전속력 R로 계속해서 프레임을 전송할 수 있도록 허용한다.
* 노드가 충돌을 감지하고 언제 재전송할지 각자 결정하므로 분산되어 있다.
* 매우 단순하다.

단점
* 노드는 슬롯이 언제 시작하는지 동기화되어있어야 한다.
* 활성 노드가 많이 있으면 일부 슬롯이 충돌로 인해 결과적으로 낭비된다.
* 모든 활성 노드가 확률적인 전송 정책 때문에 전송을 억제하는 경우 일부 슬롯이 비게 된다.

#### CSMA

위 두 프로토콜에서는 다른 노드가 전송하고 있건 말건 일단 보낸다.
즉, 충돌이 생기고 결과적으로 효율이 떨어진다.

CSMA는 보내기 전에 다음 사항을 확인한다.

* 채널이 사용 가능한지 감지되면, 전체 프레임을 전송한다.
* 채널이 사용 중인 것으로 감지되면, 전송을 연기한다.

#### CSMA에서 충돌이 발생하는 경우

![](https://velog.velcdn.com/images/dongchyeon/post/8aeaa135-0d12-481f-a935-c5dc821f5338/image.png)

1. 시각 t0에 노드 B가 다른 노드가 아무것도 전송하고 있지 않으므로 채널이 비어있는 것으로 감지한다.
2. B는 전송을 시작하고, 전송한 비트들이 브로드캐스트 매체를 따라 양방향으로 전송되다.
3. D가 t1 시점에 전송할 프레임이 생겼고, 노드 B가 t1에 전송을 하고 있음에도 전송되는 비트들이 D에 도달하지 못했다. 따라서 D는 t1일 때 채널이 사용되지 않는 것으로 감지한다.
4. D가 전송을 시작하고, 잠시 후 B가 전송한 비트와 D의 전송한 비트가 간섭을 일으키기 시작한다.

위의 예에서 확인할 수 있듯이 `채널 종단 간의 채널 전파 지연(channel propagation delay)`는 CSMA의 성능을 결정하는 데 중요한 역할을 한다.

#### CSMA/CD

![](https://velog.velcdn.com/images/dongchyeon/post/e3b8aad1-8e74-44c3-b280-ebdc5948b2ff/image.png)

CSMA는 충돌 검출을 수행하지 않는 반면, CSMA/CD는 충돌 검출을 수행한 후 즉시 전송을 취소한다.

전송 시그널의 강도를 감지해서 충돌여부를 판단한다. (두 개의 이상의 신호가 겹치면 신호의 강도가 쎼진다)
충돌이 감지되면 전송을 취소하고 jam 시그널을 광고해서 다른 노드도 보내지 않도록 한다.

**동작 과정**

1. 어댑터는 네트워크 계층으로부터 데이터그램을 받아서 링크 계층 프레임을 만든 후 어댑터 버퍼에 저장한다.
2. 어댑터는 채널이 유휴(idle) 상태임을 감지하면 프레임 전송을 시작한다.
3. 전송하는 동안 어댑터는 브로드캐스트 채널을 사용하는 다른 어댑터로부터의 신호 에너지가 있는지 감시한다.
4. 프레임 전체를 전송하는 동안 다른 어댑터로부터의 신호 에너지가 감지되지 않으면, 프레임 전송을 완료한다. (감지되면 전송을 취소한다.)
6. 전송 취소 후 임의의 랜덤 시간만큼 기다린 후 2단계로 돌아간다.

## 스위치 근거리 네트워크

스위치는 링크 계층에서 동작하기 때문에 링크 계층 프레임을 교환한다.
또한, 네트워크 계층 주소를 인식하지 않으며, 2계층 스위치들로 구성된 네트워크에서 경로를 결정하는 데 OSPF 같은 라우팅 알고리즘을 사용하지 않는다.
즉, IP가 아닌 링크 계층 주소를 사용한다.

### MAC 주소

MAC 주소는 링크 계층 주소로, 대부분의 랜의 경우 MAC 주소는 길이가 6바이트이며, 따라서 2^48개만큼의 사용 가능한 랜 주소가 있다.
IEEE가 MAC 주소 공간을 관리하여 모든 어댑터가 다른 주소를 갖게끔 한다.
MAC 주소는 게층 구조가 아닌 평면 구조를 가지고, 위치가 변하더라도 바뀌지 않는다.
IP 주소가 마치 우편번호처럼 쓰였다면 MAC주소는 주민등록번호처럼 사용되는 것이다.

### ARP

네트워크 계층 주소와 링크 계층 주소가 있으므로 이들 주소 사이에 변환을 해주는 프로토콜을 `ARP(Address Resolution Protocol)`이라고 한다.

#### ARP 동작 과정

각 호스트와 라우터는 자신의 메모리에 `ARP 테이블(ARP table)`을 갖고 있다.
이 테이블은 IP 주소와 MAC 주소 간의 매핑 정보를 포함하며, 테이블에서 각 테이블이 언제 삭제되는지를 나타내는 `TTL(Time-To-Live)`값을 포함한다.

다음 상황을 가정해보자
A는 B에게 데이터그램을 보내고자 한다.
B의 MAC 주소는 A의 ARP table에 존재하지 않는다.

1. A는 B의 IP 주소가 담긴 ARP 질의 패킷을 브로드캐스트한다.
-> LAN에 존재하는 모든 노드가 ARP 질의 패킷을 받는다.
2. B는 ARP 질의 패킷을 받고, B의 MAC 주소와 함께 응답한다.
3. A는 IP 주소와 MAC 주소 쌍을 ARP table에 갱신하고 TTL 동안 유지한다.

즉, 노드의 `ARP 테이블(ARP table)`은 `플러그 앤 플레이(plug-and-play)`다. 즉, 관리자가 구성하지 않아도 자동으로 구축된다.

#### 서브넷에 없는 노드로의 데이터그램 전송

![](https://velog.velcdn.com/images/dongchyeon/post/34311502-04c3-48b9-a852-260b1e20fc30/image.png)

위 그림에서 호스트 `111.111.111.111`이 호스트 `222.222.222.222`로 IP 데이터그램을 전송하려한다고 가정하자.
라우터는 2개의 IP 주소, 2개의 ARP 모듈, 2개의 어댑터를 가지고 있다.
송신 호스트는 적절한 목적지 MAC 주소와 IP 주소가 포함된 데이터그램을 자신의 어댑터로 전달해야 한다.

만약, 송신 어댑터가 목적지의 MAC 주소인 `49-BD-D2-C7-56-2A`를 사용하면 목적지 주소는 `111.111.111.111` 호스트가 포함된 서브넷에 있는 어느 어댑터의 MAC 주소와도 일치하지 않으므로 전달되지 않고 사라진다.

데이터그램이 전달되기 위해서는 라우터 인터페이스 `111.111.111.110`으로 전달해야만 한다. 따라서 이 프레임에 대한 적절한 MAC 주소는 라우터 인터페이스인 E6-E9-00-17-BB-4B이다.

A를 `111,111,111,111`, B를 `111.111.111.110`, R을 라우터라고 가정하자.

1. A는 출발 IP 주소를 A로, 목적지 주소를 B로 하는 IP 데이터그램을 생성한다.
2. A는 R의 MAC 주소를 목적지 주소로 하는 링크 계층 프레임을 생성하고, 프레임에는 A에서 B로 가는 IP 데이터그램이 포함된다.
3. 프레임이 A에서 R로 전송된다.
4. R에서 프레임이 수신되고, 데이터그램이 제거되어 IP 계층으로 전달된다.
5. R은 출발 IP 주소를 A로, 목적지 주소를 B로 하는 데이터그램을 전달한다.
6. R은 B의 MAC 주소를 목적지 주소로 하는 링크 계층 프레임을 생성하고, 프레임에는 A에서 B로 가는 IP 데이터그램이 포함된다.

### 이더넷

오늘날 이더넷은 가장 우세한 랜 기술로 인터넷이 글로벌 네트워킹에 대한 것이라면, 이더넷은 근거리 네트워킹에 대한 것이다.

### 이더넷 프레임 구조

![](https://velog.velcdn.com/images/dongchyeon/post/28059b62-2fad-481f-84ef-40193bb33599/image.png)

* 데이터 필드(46~1500 바이트)
  - 이 필드는 IP 데이터그램을 운반한다.
  - 1500바이트를 초과하면 호스트가 단편화해야한다는 것을 의미한다.
* 목적지 주소(6바이트)
  - 목적지 MAC 주소가 들어간다.
* 출발지 주소(6바이트)
  - 출발지 MAC 주소가 들어간다.
* 타입 필드(2바이트)
  - 네트워크 계층 프로토콜을 이더넷으로 하여금 다중화하도록 허용한다.
  - 즉, IP 이외의 네트워크 계층 프로토콜을 사용할 수 있게끔 한다.
* 순환 중복 검사(CRC)(4바이트)
  - CRC 필드의 목적은 수신 어댑터가 프레임에 오류가 생겼는지 검출할 수 있게 하는 것이다.
* 프리앰블 (8바이트)
  - 이더넷 프레임은 8바이트의 프리앰블(preamble) 필드로 시작한다.
  - 프리앰블의 첫 7바이트는 `10101010` 값을 갖고 나머지 바이트는 `10101011`이다.
  - 프리앰블의 첫 7바이트는 수신 어댑터를 깨우고, 수신자의 클록을 송신자의 클록과 동기화하는 역할을 한다.
  
### 이더넷의 비연결형 서비스(connectionless service), 비신뢰적인(unreliable) 서비스

* 비연결형 : 송신 어댑터는 데이터그램을 전송할 때 핸드셰이킹하지 않고 이더넷 프레임에 캡슐화해서 전송한다.
* 비신뢰적 : 수신 어댑터는 CRC 검사를 통해 프레임을 검사하지만 이에 대한 확인 응답 혹은 부정 확인 응답을 보내지 않는다. -> 실패하면 폐기한다.

애플리케이션이 UDP 또는 TCP를 사용하는지에 따라 데이터그램의 손실을 알 수 있음이 결정된다.
UDP의 경우 알 수 없고, TCP는 확인 후 재전송하게 할 것이다.
즉, 이더넷은 전송하고 있는 데이터그램이 재전송인지 새로운 데이터그램인지 구분할 수 없다.

### 링크 계층 스위치

스위치의 역할은 들어오는 링크 계층 프레임을 수신해서 출력 링크로 전달하는 것이다.

각 들어오는 링크에서 이더넷 프로토콜을 사용하지만, 충돌은 발생하지 않는다.
전이중(full-duplex) 방식을 사용한다.

* 적극적인 역할 수행
  - 이더넷 프레임을 저장하고 전달한다.
  - 들어오는 프레임의 MAC 주소를 검사하여, 프레임이 전달되어야 할 대상 세그먼트의 하나 이상의 출력 링크로 선택적으로 전달한다. 세그먼트로 프레임을 전달할 때는 CSMA/CD를 사용한다.
* 투명성
  - 호스트들은 스위치의 존재를 인식하지 못한다.
* 플러그 앤 프레이(plug-and-play), 자가 학습
  - 스위치는 구성 설정이 필요하지 않다.
  
#### 스위치 테이블
* 스위치 테이블 (switch table)
  - 랜상의 모든 호스트와 라우터는 아니지만 일부 노드에 대한 엔트리가 포함되어 있다.
  - 프레임을 받으면, 송신자의 정보를 학습한다.
  - 스위치 테이블 엔트리 구성
    - MAC 주소
    - MAC 주소로 가게 하는 스위치 인터페이스
    - 해당 엔트리가 만들어진 시점 (TTL)
    
#### 스위치 테이블 엔트리의 동작

목적지 주소를 가진 프레임이 스위치 인터페이스 x에 도달했다고 하자.

* 테이블에 목적지 주소에 대한 엔트리가 없는 경우
  * 스위치는 프레임의 복사본을 프레임이 수신된 인터페이스를 제외한 모든 인터페이스의 출력 버퍼로 전달한다. (flood)
* 테이블에 목적지 주소가 x 인터페이스에 연관된 엔트리가 있는 경우
  - 프레임을 다른 인터페이스로 전달할 필요가 없다.
* 테이블에 목적지 주소가 y != x 인터페이스와 연관된 엔트리가 있는 경우
  - 프레임은 y 인터페이스에 접속된 랜 세그먼트로 전달되어야 한다.
  - 즉, 해당 인터페이스 출력 버퍼에 프레임을 넣음으로써 포워딩 기능을 수행한다.
  
### 스위치 vs. 라우터

둘 다 저장 후 전달 방식이며 라우터는 네트워크 계층의 장치, 스위치는 링크 계층의 장치이다.

둘 다 포워딩 테이블을 가지고 있으며 라우터는 라우팅 알고리즘과 IP 주소를 통해 테이블을 계산한다. 그에 반해 스위치는 flooding(=broadcasting), 자가학습, MAC 주소를 통해 포워딩 테이블을 생성한다.

## 데이터 센터 네트워킹

### 로드 밸런싱

1. 외부 클라이언트의 요청을 지원하기 위해, 애플리케이션에서는 공용 IP 주소가 할당되며 클라이언트는 이 IP 주소로 요청을 보내고 응답을 받는다.
2. 요청을 `로드 밸런서`로 보낸다.
    - 일반적으로 여러 `로드 밸런서`를 갖고 있으며, 각 `로드 밸런서`는 특정 클라우드 애플리케이션을 위해 사용된다.
    - `로드 밸런서`는 목적지 IP 주소 뿐만 아니라 목적지 포트를 보고 결정하기 때문에 4계층 스위치라고도 한다.
3. `로드 밸런서`는 요청을 호스트로 분배하고 호스트의 현재 부하 상태에 따라서 호스트 간의 부하를 균등하게 한다.
    - `로드 밸런서`는 호스트의 공용 외부 IP 주소를 내부 IP 주소로 변환해주고 그 반대 변환도 해주기 때문에 NAT와 유사한 기능을 제공한다.

클라이언트가 호스트와 직접 통신하지 못하게 하여 내부 구조를 숨기고 보안을 제공한다.

## 총정리 : 웹페이지 요청에 대한 처리

![](https://velog.velcdn.com/images/dongchyeon/post/39c9ca3a-f28b-41b0-b471-7c3abfb27abc/image.png)

Bob이 학교의 이더넷 스위치에 랩탑을 연결하고 `www.google.com`을 다운로드하는 과정을 보자.

* 랩탑을 연결하려면 DHCP 서버를 통해 IP 주소, First-hop 라우터, DNS 서버의 주소를 알아내야 한다. 
* DHCP 요청은 UDP에 캡슐화되고, IP에 캡슐화되며, Ethernet에 캡슐화된다.
* 이더넷 프레임이 LAN에서 브로드캐스트되고, DHCP 서버가 동작하는 라우터에서 수신된다.
* 이더넷에서 IP로, IP에서 UDP로 역다중화되며, UDP에서 DHCP로 역다중화된다.
* DHCP 서버는 클라이언트의 IP 주소, 클라이언트의 first-hop 라우터의 IP 주소, DNS 서버의 이름 및 IP 주소를 포함한 DHCP ACK를 구성한다.
* DHCP 서버에서 캡슐화가 이루어지고, 프레임은 LAN을 통해 전달되며 (스위치 learning을 통해), 클라이언트에서 역다중화된다.
* DHCP 클라이언트는 DHCP ACK 응답을 수신한다.

이제 클라이언트는 IP주소를 가지고 있으며, DNS 서버의 이름과 주소, 클라이언트의 first-hop 라우터를 알고 있다.

* HTTP 요청을 보내기 전에 www.google.com의 IP 주소가 필요하다: DNS
* DNS 쿼리가 생성되고, UDP에 캡슐화되고, IP에 캡슐화되며, Ethernet에 캡슐화된다. 라우터로 프레임을 보내기 위해 라우터 인터페이스의 MAC 주소가 필요하다: ARP
* ARP 질의가 브로드캐스트되고, 라우터에서 수신되며, 라우터는 라우터 인터페이스의 MAC 주소를 제공하는 ARP 응답을 보낸다.

클라이언트는 이제 first-hop 라우터의 MAC 주소를 알고 있으므로 DNS 질의를 포함한 프레임을 보낼 수 있다.
* LAN 스위치를 통해 클라이언트에서 first-hop 라우터로 DNS 질의를 포함한 IP 데이터그램이 전달된다.
* 캠퍼스 네트워크에서 Comcast 네트워크로 IP 데이터그램이 전달되고, DNS 서버로 라우팅된다. (라우팅 테이블은 RIP, OSPF, BGP 라우팅 프로토콜 등으로 생성)


* DNS 서버로 역다중화된다.
* DNS 서버는 www.google.com의 IP주소를 클라이언트에 응답한다.
* HTTP 요청을 보내기 위해 클라이언트는 먼저 웹 서버에 대한 TCP 소켓을 연다.
* TCP SYN 세그먼트가 google의 웹서버로 라우팅된다.
* 웹 서버는 SYN ACK로 응답한다. -> TCP 연결이 설정

* HTTP 요청이 TCP 소켓을 통해 보내진다.
* HTTP 요청을 포함한 IP 데이터그램이 www.google.com으로 라우팅된다.
* 웹 서버는 웹 페이지를 포함한 HTTP 응답을 보낸다.
* 해당 IP 데이터그램이 클라이언트로 돌아온다.
